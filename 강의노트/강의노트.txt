#0.1 
백엔드 : ExpressJS/ app.get()/ pug/ (req,res) =>  / package.json / babel / nodemon
이것들을 알고 있어야 진행 가능함
프론트엔드 : 바닐라JS 
.classList.add() 등등

#0.2 서버 설정
zoom 폴더 아래에 npm init -y 입력
package.json 에 main, scripts 부분 지우기
설명이랑 라이선스 넣고 싶은것 넣기
npm i nodemon -D
./babel.config.json 랑 nodemon.json 파일 만들기
./src/server.js 만들고 console.log("hi");
//nodemon, babel을 설치함

npm i @babel/core -D @babel/cli -D @babel/node -D @babel/preset-env -D 
//-D의미는 package.json에 devDependencies에 추가한다는 의미 

.gitignore 만들어서 /node_modules 폴더를 업데이트 안하도록 막기

nodemon.json 에 
{
    "exec" : "babel-node src/server.js"
} 추가해서 exec 명령어를 하면 다음과 같은 명령이 실행되도록 함

babel.config.json에
{
    "presets": ["@babel/preset-env"]
} 추가해서 preset을 설정함

package.json 파일에서 devDependencies에 잘 설치되었는지 확인

package.json 파일에서 license 아래 
  "scripts": {
    "dev" : "nodemon"
  },
추가 의미는 dev는 nodemon을 호출하고 nodemon이 nodemon.json을 살펴보고 exec에 적혀있는 것을 설치함 

//npm run dev 하면 어떤일이 벌어지느냐
//package.json에 scripts:{"dev":"nodemon"}
//nodemon.json에서 exec할때 babel-node src/server.js 로 서버 js 경로를 제시해줌
//babel.config.json에서 presets @babel/preset-env 를 부름


npm i express / npm i pug  설치해줌

src/server.js 에 들어가서 
import express from "express";

const app = express();

console.log("hello");

app.listen(3000);
입력해줌 3000 으로 서버를 열겠다는 의미

npm run dev 만약 babel-node는 ~실행안되면 npm i @babel/node -g 글로벌 옵션으로 설치하면 됨

오늘한거는 babel nodemon express를 이용해 nodeJS 프로젝트를 구축한거임


#0.3 프론트엔드 설정
src/public/js/app.js 새로 만들기

src.server.js에
app.set('view engine', 'pug');
app.set('views', __dirname + "/src/views"); 코드를 const app = express(); 아래에 추가해주고 

src/views/home.pug 파일을 만들어주고 html을 작성함
html:5 를 입력하면 자동생성해줌
title 을 자기가 원하는 제목으로 
doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(http-equiv="X-UA-Compatible", content="IE=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        title Yoom
    body 
        h1 It works!
이런식으로 작성해줌

src/server.js에 
import express from "express";//express는 views를 설정해주고 render 시켜주는 역할만 함
//나머지는 웹소켓에서 할것임
const app = express();
app.set('view engine', 'pug');
app.set('views', __dirname + "/views");

app.get('/', (req, res) => res.render("home"));

const handleListen = () => console.log(`Listening on http://localhost:3000`);
app.listen(3000, handleListen);
하고 localhost:3000 하면 It works 페이지가 보일것이다.

src/views/home.pug 에 우리가 원하는 스크립트를 넣으면 된다.
It works 아래에 script(src="/public/js/app.js") 추가
하지만 페이지를 새로고침 하면 못 불러오는데 다시 src/server.js로 가서
app.use("public", express.static(__dirname + "/public")) // home.pug에서 static으로 안해주면 app.js 를 불러올 수 없다.
이 코드를 app.set('views', __dirname + "/views"); 아래에 추가해줘야함

nodemon.json에서 "ignore": ["src/public/*"], 추가해주면 해당 src/public 아래 파일들이 수정될 때마다 재실행 되지 않음

MVP Css를 통해서 home.pug를 예쁘게 꾸며보자
        title Yoom 밑에
        link(rel="stylesheet" href="https://unpkg.com/mvp.css")
home.pug에 추가해줌


    body 
        header
            h1 Yoom
        main
            h2 Welcome to Yoom
        button Call
        script(src="/public/js/app.js")
하고 public/js/app.js alert('hi') 해서 localhost:3000에서 잘 동작하는지 확인해보기 

#0.4

nodemon.json에 ignore는 수정되었을때도 서버 재시작 안한다는 의미
exec는 실행하는 부분인데 babel은 우리가 작성한 코드를 NodeJs코드로 컴파일 해주는 역할 그 경로를 src/server.js에 함

babel-node를 실행시키면 babel.config.json을 찾아 코드에 적용시킬 preset을 실행


#1.1 채팅시스템 만들기
HTTP 				vs 				WebSokets
req -> 					websoket req ->
     <- res					     <- websoket accept
req -> 						  -><- * 여러번
     <- res					     <- websoket connection closed
stateless: backend가 유저를			http://~.com 말고 ws://~.com 이런식으로 쓸 수 있음
알지 못한다.				서버와 유저가 계속 연결되어있음 
response 후 유저를 까먹음			req res 과정이 계속 진행되지 않음
authentification측면에서 취약		bi-directional 연결
유저를 기억하기 위해			js에 웹소켓을 이용할 수 있도록 구현되어있고
cookie를 이용함				브라우저에는 내장된 websoket API 가 있음
realtime 아님				user backend 뿐 아니라 backend backend 도 가능함
유저는 req만 backend는 res만

#1.2 Websoket in NodeJS
ws라는 라이브러리 사용 http://npmjs.com/package/ws
ws를 이용한 framework가 있음 이걸 이용할꺼임
npm i ws

import http from "http"
import WebSocket from "ws"

const server = http.createServer(app);//http 서버 생성
const wss = new WebSocket.Server({server});//webSoket 서버 

http server는 굳이 필요하지 않지만 views, static files, home, redirection 기능을 위해 추가함

#1.3 Websocket Event
backend에 접속하는 것은 js가 해준다 브라우저에 다 깔려있음(WebSoket() 생성자)

websocket에도 evnetlistener가 존재함

function handleConnetion(socket){
    console.log(socket);
}
wss.on("connection", handleConnetion); //handleConnetion은 callback 함수
//연결이벤트, function, socket:메시지 주고받는 통로(객체) backend에 연결된 사람의 정보 제공해줌
이 코드를 server.js 에 추가한다고 해도 backend에 접속한 기록이 없을것이다.
따라서 front에서 back으로 연결하는 코드를 public/js/app.js에 추가해준다.

const socket = new WebSocket('http://localhost:3000')//app.js에 추가하고 재시작하면 http 프로토콜이 아니라는 
에러가 남

브라우저에서 http://localhost:3000 말고 ws://localhost:3000을 가져오게 하자
콘솔로 들어가 window.location.host 검색하면 호스트 주소가 출력됨 -> 이러면 다른환경(스마트폰)에서도 접속 가능
app.js
const socket = new WebSocket(`ws://${window.location.host}`);

바꾸고 브라우저 새로고침 하면 
WebSocket {
  _events: [Object: null prototype] { close: [Function (anonymous)] },
  _eventsCount: 1,
어쩌구 저쩌구 나오는데 이제 socket 객체로 통신이 가능함

server.js(backend)의 socket 변수는 연결된 브라우저를 의미하고 app.js(frontend) socket 변수는 서버를 의미함

#1.4 웹 소켓 메시지
Server.js
wss.on("connection", (socket) => {
    socket.send("connected to server");
    socket.on("close", () => console.log("disconnected from browser"));//브라우저가 꺼졌는지 추적
    socket.send("hello");//Hello라는 메시지 보냄
});

public/js/app.js
const socket = new WebSocket(`ws://${window.location.host}`); //소켓열고
open message close 이벤트 리스너 생성

#1.5 복습

#1.6 웹 소켓 채팅 서버 만들기
server.js 
const sockets = [];
    socket.on("message", message => {
        sockets.forEach(aSocket => aSocket.send(message.toString()));//DB에 있는 모든 소캣을 aSocket에 담고 send 함
        //socket.send(message.toString());
    });//브라우저가 서버로 메시지를 보냈을때 listener, 브라우저 메시지 그대로 다시 브라우저로, 서버 - 브라우저 1:1 관계만 연결되어있음

#1.7

json stringify

#1.8 
왜 socket.send 하면 string으로만 날라가는가?
이유는 언어에 구애받지 않기 위해서 String으로 날림 누구는 GO 누구는 JS로 서버를 만드는데 send가 JS만 지원하면 안되니
모든 언어가 가지고 있는 String으로 메시지를 보냄(WebSocket -> 브라우저 API에 정의되어있음)

#1.9 결론
프레임워크를 사용하여 우리가 구현한 것들이 정의되어있는 그런 프레임워크 사용방법을 배울꺼임

#2.0 SocketIo vs WebSockets
socketIo 라이브러리
실시간 양방향 event 기반
websocket을 지원하지 않아도 HTTP long-polling 등 다른 라이브러리를 사용한다.
websocket으로 구현되지 않는 부분도 있음 (자동 재 접속기능 등등)
websocket으로 연결되지 않으면 socketIo는 다른 방법을 찾아감
websocket의 부가기능이 아님 websocket을 포함하고 있음

#2.1 socketIO
localhost:3000/socket.io/socket.io.js 에 각종 function들이 정의 되어있음
websocket의 부가기능이 아니므로 서버와 브라우저에도 socketio도 설치해야함(브라우저에는 websocket API만 있으므로)

#2.2 SocketIO is Amazing
socket.send = socket.emit(내가 정한 이벤트 이름, data object, 보낼 함수) // app.js(브라우저)
socket.on(내가정한 이벤트 이름, 실행할 함수)//server.js

app.js(브라우저)
function handleRoomSubmit(event){
    event.preventDefault();
    const input = form.querySelector("input");
    socket.emit("enter_room", {payload:input.value}, () => {
        console.log("server is done!");
    });//emit(event이름, dataobject(string이 아니여도 됨))
    input.value = "";
}//emit 할때 함수도 보낼 수 있음

server.js(서버)
wsServer.on("connection", socket => {
    socket.on("enter_room", (msg, done) => {
        console.log(msg);
        setTimeout(() => {
            done();
        }, 10000);//done 이라는 변수에 프론트의 함수를 실행 할 수 있음
    });//브라우저에서 보내는 emit(이벤트이름, 실행할 함수)
});//브라우저에서 오는 connection 받기

#2.3
app.js (브라우저) 에서 socket.emit("서버에서 받을 메시지 타입", data object 여러개 보낼 수 있음, ...)
서버를 종료하면 자동으로 app.js에서 재연결을 시도함

server.js
socket.on("enter_room", (a,b,c,d,e,f,... ) => {
        console.log(a,b,c,d,e,f,...);
    });//하면 다 찍힘 인자가 몇개이던간에
함수(함수는 반드시 마지막 인자)를 보내는것도 가능한데 백엔드에서 처리가 너무 오래 걸리면 프론트엔드에서
미리 처리하고 넘길만한것

app.js
function backendDone(msg){
    console.log(`backend says : ` + msg);
}
socket.emit("enter_room", {payload:input.value}, backendDone);
//함수를 실행시킬려면 마지막 인자가 프론트에 정의된 함수여야함

server.js
socket.on("enter_room", (roomName, done) => {
        console.log(roomName);
        setTimeout(()=>{
            done("hello");
        }, 5000)
    });
server.js에서 실행되는 done() 함수는 프론트엔드에 있는 함수만을 실행시킴(사용자가 이상한 코드를 주입해서 
그 코드를 그대로 실행하면 안되므로)
server.js는 단순히 프론트엔드에 있는 함수를 실행하라는 명령을 내리는 역할을 함 인자는 백엔드(server.js)에서 준 걸로 실행

#2.4 Rooms















